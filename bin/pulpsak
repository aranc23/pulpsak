require "thor"
require "pulpsak"
require "text-table"

class Remotes < Thor
  desc "list", "list all remotes"
  def list()
    remotes_api = PulpRpmClient::RemotesRpmApi.new
    table = Text::Table.new
    table.head = ["last update","name","url","download_concurrency","policy"]
    table.rows = []
    remotes_api.list.results.each do |remote|
      table.rows << [
        remote.pulp_last_updated.to_time,
        remote.name,
        remote.url,
        remote.download_concurrency.to_s,
        remote.policy,
      ]
    end
    print table.to_s
  end
  desc "create [NAME] [URL]", "create remote"
  method_option :ca_cert, :type => :string, :default => nil, :desc => "A PEM encoded CA certificate used to validate the server certificate presented by the remote server."
  method_option :client_cert, :type => :string, :default => nil, :desc => "A PEM encoded client certificate used for authentication."
  method_option :client_key, :type => :string, :default => nil, :desc => "A PEM encoded private key used for authentication."
  method_option :tls_validation, :type => :boolean, :default => nil, :desc => "If True, TLS peer validation must be performed."
  method_option :proxy_url, :type => :string, :default => nil, :desc => "The proxy URL. Format: scheme://user:password@host:port"
  method_option :username, :type => :string, :default => nil, :desc => "The username to be used for authentication when syncing."
  method_option :password, :type => :string, :default => nil, :desc => "The password to be used for authentication when syncing."
  method_option :download_concurrency, :type => :numeric, :default => nil, :desc => "Total number of simultaneous connections."
  method_option :policy, :type => :string, :default => nil, :desc => "The policy to use when downloading content. The possible values include: 'immediate', 'on_demand', and 'streamed'. 'immediate' is the default."
  method_option :sles_auth_token, :type => :string, :default => nil, :desc => "Authentication token for SLES repositories."

  def create(name,url)
    remotes_api = PulpRpmClient::RemotesRpmApi.new
    options[:name] = name
    options[:url] = url
    pp remotes_api.create(options)
  end
  desc "update [NAME]", "create remote"
  method_option :ca_cert, :type => :string, :default => nil, :desc => "A PEM encoded CA certificate used to validate the server certificate presented by the remote server."
  method_option :client_cert, :type => :string, :default => nil, :desc => "A PEM encoded client certificate used for authentication."
  method_option :client_key, :type => :string, :default => nil, :desc => "A PEM encoded private key used for authentication."
  method_option :tls_validation, :type => :boolean, :default => nil, :desc => "If True, TLS peer validation must be performed."
  method_option :proxy_url, :type => :string, :default => nil, :desc => "The proxy URL. Format: scheme://user:password@host:port"
  method_option :username, :type => :string, :default => nil, :desc => "The username to be used for authentication when syncing."
  method_option :password, :type => :string, :default => nil, :desc => "The password to be used for authentication when syncing."
  method_option :download_concurrency, :type => :numeric, :default => nil, :desc => "Total number of simultaneous connections."
  method_option :policy, :type => :string, :default => nil, :desc => "The policy to use when downloading content. The possible values include: 'immediate', 'on_demand', and 'streamed'. 'immediate' is the default."
  method_option :sles_auth_token, :type => :string, :default => nil, :desc => "Authentication token for SLES repositories."
  method_option :url, :type => :string, :default => nil, :desc => "update the url"
  method_option :rename, :type => :string, :default => nil, :desc => "rename the remote"

  def update(name)
    remotes_api = PulpRpmClient::RemotesRpmApi.new
    remote = Pulpsak.remote_inspect_by_name(name)
    if options[:rename]
      options[:name] = options[:rename]
      options.delete('rename')
    else
      options[:name] = remote.name
    end
    if not options[:url]
      options[:url] = remote.url
    end
    pp remotes_api.update(remote.pulp_href,options)
  end
  desc "delete [NAME]", "delete a remote"
  def delete(name)
    pp PulpRpmClient::RemotesRpmApi.new.delete(Pulpsak.remote_inspect_by_name(name).pulp_href)
  end
end
class RepositotyVersions < Thor
  desc "list [NAME]", "list all repo versions"
  def list(name)
    repover_api = PulpRpmClient::RepositoriesRpmVersionsApi.new
    if repo = Pulpsak.repository_inspect_by_name(name)
      table = Text::Table.new
      table.head = ["created","number","added","present","removed"]
      table.rows = []
      repover_api.list(repo.pulp_href).results.each do |rver|
        #pp rver
        table.rows << [
          rver.pulp_created.to_time,
          rver.number.to_s,
          rver.content_summary.added.length,
          rver.content_summary.present.length,
          rver.content_summary.removed.length,
        ]
      end
      print table.to_s
    end
  end
end
class Repositories < Thor
  desc "list", "list all repos"
  def list()
    remotes_api = PulpRpmClient::RemotesRpmApi.new

    table = Text::Table.new
      table.head = ["created","name","keep","remote"]
      table.rows = []
      PulpRpmClient::RepositoriesRpmApi.new.list.results.each do |dist|
        table.rows << [dist.pulp_created.to_time,dist.name,dist.retain_package_versions,(dist.remote ? remotes_api.read(dist.remote).url : '')]
      end
      print table.to_s
  end

  desc "sync [NAME]", "call sync on repo"
  method_option :mirror, :type => :boolean, :default => false, :desc => "mirror true removes rpms, false is merely additive"
  def sync(name)
    repo_api = PulpRpmClient::RepositoriesRpmApi.new
    repo_api.list.results.each do |dist|
      if dist.name == name
        pp repo_api.sync(dist.pulp_href,{mirror: options[:mirror]})
        break
      end
    end
  end
  desc "create [NAME]", "create a repository"
  method_option :description, :type => :string, :default => nil, :desc => "An optional description."
  method_option :retain_package_versions, :type => :numeric, :default => 0, :desc => "The number of versions of each package to keep in the repository; older versions will be purged. The default is '0', which will disable this feature and keep all versions of each package."
  method_option :remote, :type => :string, :default => nil, :desc => "name of existing remote"
  method_option :metadata_signing_service, :type => :string, :default => nil, :desc => "A reference to an associated signing service."
  def create(name)
    options[:name] = name
    if options[:remote]
      if remote = Pulpsak.remote_inspect_by_name(options[:remote])
        options[:remote] = remote.pulp_href
      else
        raise ArgumentError, "could not find remote #{options[:remote]}"
      end
    end
    repo_api = PulpRpmClient::RepositoriesRpmApi.new
    pp repo_api.create(options)
  end
  desc "update [NAME]", "update a repository"
  method_option :rename, :type => :string, :default => nil, :desc => "A (new) unique name for this repository."
  method_option :description, :type => :string, :default => nil, :desc => "An optional description."
  method_option :retain_package_versions, :type => :numeric, :default => 0, :desc => "The number of versions of each package to keep in the repository; older versions will be purged. The default is '0', which will disable this feature and keep all versions of each package."
  method_option :remote, :type => :string, :default => nil, :desc => "name of existing remote"
  method_option :metadata_signing_service, :type => :string, :default => nil, :desc => "A reference to an associated signing service."
  def update(name)
    repo_api = PulpRpmClient::RepositoriesRpmApi.new
    opts = {}

    repo = Pulpsak.repository_inspect_by_name(name)
    if options[:remote]
      if remote = Pulpsak.remote_inspect_by_name(options[:remote])
        opts[:remote] = remote.pulp_href
      else
        raise ArgumentError, "could not find remote #{options[:remote]}"
      end
    end
    if options[:description]
      opts[:description] = options[:description]
    end
    if options[:metadata_signing_service]
      opts[:metadata_signing_service] = options[:metadata_signing_service]
    end
    if options[:retain_package_versions]
      opts[:retain_package_versions] = options[:retain_package_versions].to_i
    end
    
    if options[:rename]
      opts[:name] = options[:rename]
      pp repo_api.update(repo.pulp_href,opts)
    else
      pp repo_api.partial_update(repo.pulp_href,opts)
    end
  end
  desc "delete [NAME]", "delete a repository"
  def delete(name)
    pp PulpRpmClient::RepositoriesRpmApi.new.delete(Pulpsak.repository_inspect_by_name(name).pulp_href)
  end
  desc "versions", "manage repository versions"
  subcommand "versions", RepositotyVersions
end
class Distributions < Thor
  desc "list", "list all distributions"
  def list()
    pubs = PulpRpmClient::PublicationsRpmApi.new

    table = Text::Table.new
      table.head = ["created","name","base","pub->repo"]
      table.rows = []
      PulpRpmClient::DistributionsRpmApi.new.list.results.each do |dist|
        pp dist
        repo_info = 'ORPHAN'
        if dist.publication and pub = pubs.read(dist.publication) and pub.repository
          repo_info = Pulpsak.repository_inspect(pub.repository).name +
                      ':' +
                      Pulpsak.repository_version_inspect(pub.repository_version).number.to_s
        end
        table.rows << [dist.pulp_created.to_time,dist.name,dist.base_path,repo_info]
      end
      print table.to_s
  end
  desc "create [NAME] [BASE_PATH] [REPO]", "create a repository using a unique name, base path, and repository specification"
  method_option :version, :type => :numeric, :default => 0, :desc => "Integer version number of repository to reference, default is to use the latest"
  method_option :metadata_checksum_type, :type => :string, :default => 'sha256', :desc => 'The checksum type for metadata, "unknown" "md5" "sha1" "sha224" "sha256" "sha384" "sha512"'
  method_option :package_checksum_type, :type => :string, :default => 'sha256', :desc => 'The checksum type for packages, "unknown" "md5" "sha1" "sha224" "sha256" "sha384" "sha512"'
  method_option :gpgcheck, :type => :boolean, :default => false, :desc => "An option specifying whether a client should perform a GPG signature check on packages."
  method_option :repo_gpgcheck, :type => :boolean, :default => false, :desc => "An option specifying whether a client should perform a GPG signature check on the repodata."
  method_option :content_guard, :type => :string, :default => nil, :desc => 'An optional content-guard.'
  def create(name,base_path,repo_name)
    
    pub_api = PulpRpmClient::PublicationsRpmApi.new
    #repo_api = PulpRpmClient::RepositoriesRpmApi.new
    dist_api = PulpRpmClient::DistributionsRpmApi.new
    if Pulpsak.distribution_inspect_by_name(name)
      puts("distribution already exist: #{name}\n")
      exit 1
    end
    repo = Pulpsak.repository_inspect_by_name(repo_name)
    unless repo
      puts("unable to find repository #{repo_name}\n")
      exit 1
    end
    # create a new publication for the new repo
    pub_opts = {
      :metadata_checksum_type => options[:metadata_checksum_type],
      :package_checksum_type => options[:package_checksum_type],
      :gpgcheck => options[:gpgcheck] ? 1 : 0,
      :repo_gpgcheck => options[:repo_gpgcheck] ? 1 : 0,
    }
    if options[:version]
      pub_opts[:repository_version] = repo.pulp_href + 'versions/' + options[:version].to_s + '/'
    else
      pub_opts[:repository] = repo.pulp_href
    end
    pp pub_opts
    task_href = pub_api.create(pub_opts).task
    print "creating publication"
    while Pulpsak.task_inspect(task_href).state == 'running'
      print "."
      sleep 3
    end
    print "\n"
    task = Pulpsak.task_inspect(task_href)
    pp task
    if task.state != 'completed'
      print "unable to create publication, unable to continue\n"
      exit 1
    end
    pub_href = task.created_resources[0]
    task_href = dist_api.create(
      {
        :name => name,
        :base_path => base_path,
        :content_guard => options[:content_guard],
        :publication => pub_href,
      }
    ).task
    print "creating distribution"
    while Pulpsak.task_inspect(task_href).state == 'running'
      print "."
      sleep 3
    end
    print "\n"
    task = Pulpsak.task_inspect(task_href)
    pp task
    if task.state != "completed"
      print "unable to create distibution, deleting publication"
      pub_api.delete(pub_href)
      exit 1
    end
  end
  
end
class Publications < Thor
  desc "list", "list all publications"
  def list()
    table = Text::Table.new
      table.head = ["created","repver","gpgcheck","repo_gpgcheck","metadata","package","pulp_href"]
      table.rows = []
      PulpRpmClient::PublicationsRpmApi.new.list.results.each do |pub|
        table.rows << [pub.pulp_created,Pulpsak.repository_inspect(pub.repository).name + ':' + Pulpsak.repository_version_inspect(pub.repository_version).number.to_s,pub.gpgcheck,pub.repo_gpgcheck,pub.metadata_checksum_type,pub.package_checksum_type,pub.pulp_href]
      end
      print table.to_s
  end
  desc "cleanup", "delete all publications (will skip ones in use)"
  def cleanup()
    dists = PulpRpmClient::DistributionsRpmApi.new
    pubs = PulpRpmClient::PublicationsRpmApi.new

    pub_hrefs = []
    dists.list.results.each do |dist|
      if dist.publication
        pub_hrefs.push(dist.publication)
      end
    end
    pubs.list.results.each do |pub|
      unless pub_hrefs.include?(pub.pulp_href)
        pubs.delete(pub.pulp_href)
      end
    end
  end
end

class Rpm < Thor
  desc "distributions", "manage distributions"
  subcommand "distributions", Distributions
  desc "publications", "manage publications"
  subcommand "publications", Publications
  desc "repositories", "manage repositories"
  subcommand "repositories", Repositories
  desc "remotes", "manage remotes"
  subcommand "remotes", Remotes
end

class PulpsakCli < Thor
  desc "rpm", "manage rpm plugins"
  subcommand "rpm", Rpm
end

PulpsakCli.start(ARGV)
